-module(blockchain_simple_SUITE).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("blockchain_vars.hrl").

-export([all/0, init_per_testcase/2, end_per_testcase/2]).

-define(TEST_LOCATION, 631210968840687103).

-export([
    basic_test/1,
    reload_test/1,
    restart_test/1,
    htlc_payee_redeem_test/1,
    htlc_payer_redeem_test/1,
    poc_request_test/1,
    bogus_coinbase_test/1,
    bogus_coinbase_with_good_payment_test/1,
    export_test/1,
    delayed_ledger_test/1,
    fees_since_test/1,
    security_token_test/1,
    routing_test/1,
    block_save_failed_test/1,
    absorb_failed_test/1,
    missing_last_block_test/1,
    epoch_reward_test/1,
    election_test/1,
    election_v3_test/1,
    chain_vars_test/1,
    chain_vars_set_unset_test/1,
    token_burn_test/1,
    payer_test/1,
    poc_sync_interval_test/1,
    zero_payment_v1_test/1,
    zero_amt_htlc_create_test/1,
    negative_payment_v1_test/1,
    negative_amt_htlc_create_test/1,
    update_gateway_oui_test/1
]).

-import(blockchain_utils, [normalize_float/1]).

%%--------------------------------------------------------------------
%% COMMON TEST CALLBACK FUNCTIONS
%%--------------------------------------------------------------------

%%--------------------------------------------------------------------
%% @public
%% @doc
%%   Running tests for this suite
%% @end
%%--------------------------------------------------------------------
all() ->
    [
        basic_test,
        reload_test,
        restart_test,
        htlc_payee_redeem_test,
        htlc_payer_redeem_test,
        poc_request_test,
        bogus_coinbase_test,
        bogus_coinbase_with_good_payment_test,
        export_test,
        delayed_ledger_test,
        fees_since_test,
        security_token_test,
        routing_test,
        block_save_failed_test,
        absorb_failed_test,
        missing_last_block_test,
        epoch_reward_test,
        election_test,
        election_v3_test,
        chain_vars_test,
        chain_vars_set_unset_test,
        token_burn_test,
        payer_test,
        poc_sync_interval_test,
        zero_payment_v1_test,
        zero_amt_htlc_create_test,
        negative_payment_v1_test,
        negative_amt_htlc_create_test,
        update_gateway_oui_test
    ].

%%--------------------------------------------------------------------
%% TEST CASE SETUP
%%--------------------------------------------------------------------

init_per_testcase(TestCase, Config) ->
    Config0 = blockchain_ct_utils:init_base_dir_config(?MODULE, TestCase, Config),
    Balance = 5000,
    {ok, Sup, {PrivKey, PubKey}, Opts} = test_utils:init(?config(base_dir, Config0)),
    %% two tests rely on the swarm not being in the consensus group, so exclude them here
    ExtraVars = case TestCase of
                    election_v3_test ->
                        #{election_version => 3,
                          election_bba_penalty => 0.01,
                          election_seen_penalty => 0.03};
                    _ ->
                        #{allow_zero_amount => false}
                end,
    {ok, GenesisMembers, ConsensusMembers, Keys} =
        test_utils:init_chain(Balance,
                              {PrivKey, PubKey},
                              not lists:member(TestCase, [bogus_coinbase_test, bogus_coinbase_with_good_payment_test]),
                              ExtraVars),

    Chain = blockchain_worker:blockchain(),
    Swarm = blockchain_swarm:swarm(),
    N = length(ConsensusMembers),

    % Check ledger to make sure everyone has the right balance
    Ledger = blockchain:ledger(Chain),
    Entries = blockchain_ledger_v1:entries(Ledger),
    _ = lists:foreach(fun(Entry) ->
        Balance = blockchain_ledger_entry_v1:balance(Entry),
        0 = blockchain_ledger_entry_v1:nonce(Entry)
    end, maps:values(Entries)),

    [
        {balance, Balance},
        {sup, Sup},
        {pubkey, PubKey},
        {privkey, PrivKey},
        {opts, Opts},
        {chain, Chain},
        {swarm, Swarm},
        {n, N},
        {consensus_members, ConsensusMembers},
        {genesis_members, GenesisMembers},
        Keys
        | Config0
    ].

%%--------------------------------------------------------------------
%% TEST CASE TEARDOWN
%%--------------------------------------------------------------------
end_per_testcase(_, Config) ->
    Sup = ?config(sup, Config),
    % Make sure blockchain saved on file = in memory
    case erlang:is_process_alive(Sup) of
        true ->
            true = erlang:exit(Sup, normal),
            ok = test_utils:wait_until(fun() -> false =:= erlang:is_process_alive(Sup) end);
        false ->
            ok
    end,
    ok.

%%--------------------------------------------------------------------
%% TEST CASES
%%--------------------------------------------------------------------

basic_test(Config) ->
    BaseDir = ?config(base_dir, Config),
    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),
    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),

    ?assertEqual({ok, Block}, blockchain:get_block(2, Chain)),

    Ledger = blockchain:ledger(Chain),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500, blockchain_ledger_entry_v1:balance(NewEntry0)),

    {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500, blockchain_ledger_entry_v1:balance(NewEntry1)),
    ok.

reload_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    Balance = 5000,
    ConsensusMembers = ?config(consensus_members, Config),
    Sup = ?config(sup, Config),
    Opts = ?config(opts, Config),
    Chain0 = ?config(chain, Config),
    Swarm0 = ?config(swarm, Config),
    N0 = ?config(n, Config),

    % Add some blocks
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
            _ = blockchain_gossip_handler:add_block(Swarm0, Block, Chain0, self())
        end,
        lists:seq(1, 10)
    ),
    ?assertEqual({ok, 11}, blockchain:height(Chain0)),

    %% Kill this blockchain sup
    true = erlang:exit(Sup, normal),
    ok = test_utils:wait_until(fun() -> not erlang:is_process_alive(Sup) end),

    {InitialVars, _Config} = blockchain_ct_utils:create_vars(#{num_consensus_members => N0}),

    % Create new genesis block
    GenPaymentTxs = [blockchain_txn_coinbase_v1:new(Addr, Balance + 1)
                     || {Addr, _} <- ConsensusMembers],
    GenConsensusGroupTx = blockchain_txn_consensus_group_v1:new([Addr || {Addr, _} <- ConsensusMembers], <<"proof">>, 1, 0),
    Txs = InitialVars ++ GenPaymentTxs ++ [GenConsensusGroupTx],
    NewGenBlock = blockchain_block:new_genesis_block(Txs),
    GenDir = BaseDir ++ "2",  %% create a second/alternative base dir
    File = filename:join(GenDir, "genesis"),
    ok = test_utils:atomic_save(File, blockchain_block:serialize(NewGenBlock)),

    {ok, Sup1} = blockchain_sup:start_link([{update_dir, GenDir}|Opts]),
    ?assert(erlang:is_pid(blockchain_swarm:swarm())),

    Chain = blockchain_worker:blockchain(),
    {ok, HeadBlock} = blockchain:head_block(Chain),
    ?assertEqual(blockchain_block:hash_block(NewGenBlock), blockchain_block:hash_block(HeadBlock)),
    ?assertEqual(NewGenBlock, HeadBlock),
    ?assertEqual({ok, blockchain_block:hash_block(NewGenBlock)}, blockchain:genesis_hash(Chain)),
    ?assertEqual({ok, NewGenBlock}, blockchain:genesis_block(Chain)),
    ?assertEqual({ok, 1}, blockchain:height(Chain)),

    true = erlang:exit(Sup1, normal),
    ok.

restart_test(Config) ->
    BaseDir = ?config(base_dir, Config),
    GenDir = BaseDir ++ "2",  %% create a second/alternative base dir

    ConsensusMembers = ?config(consensus_members, Config),
    Sup = ?config(sup, Config),
    Opts = ?config(opts, Config),
    Chain0 = ?config(chain, Config),
    Swarm0 = ?config(swarm, Config),
    {ok, GenBlock} = blockchain:head_block(Chain0),

    % Add some blocks
    [LastBlock| _Blocks] = lists:foldl(
        fun(_, Acc) ->
            {ok, Block} = test_utils:create_block(ConsensusMembers, []),
            _ = blockchain_gossip_handler:add_block(Swarm0, Block, Chain0, self()),
            timer:sleep(100),
            [Block|Acc]
        end,
        [],
        lists:seq(1, 10)
    ),
    ?assertEqual({ok, 11}, blockchain:height(Chain0)),

    %% Kill this blockchain sup
    true = erlang:exit(Sup, normal),
    ok = test_utils:wait_until(fun() -> not erlang:is_process_alive(Sup) end),

    % Restart with an empty 'GenDir'
    {ok, Sup1} = blockchain_sup:start_link([{update_dir, GenDir}|Opts]),
    ?assert(erlang:is_pid(blockchain_swarm:swarm())),

    Chain = blockchain_worker:blockchain(),
    {ok, HeadBlock} = blockchain:head_block(Chain),
    ?assertEqual(blockchain_block:hash_block(LastBlock), blockchain_block:hash_block(HeadBlock)),
    ?assertEqual({ok, LastBlock}, blockchain:head_block(Chain)),
    ?assertEqual({ok, blockchain_block:hash_block(GenBlock)}, blockchain:genesis_hash(Chain)),
    ?assertEqual({ok, GenBlock}, blockchain:genesis_block(Chain)),
    ?assertEqual({ok, 11}, blockchain:height(Chain)),

    true = erlang:exit(Sup1, normal),
    ok = test_utils:wait_until(fun() -> not erlang:is_process_alive(Sup1) end),

    % Restart with the existing genesis block in 'GenDir'
    ok = filelib:ensure_dir(filename:join([GenDir, "genesis"])),
    ok = file:write_file(filename:join([GenDir, "genesis"]), blockchain_block:serialize(GenBlock)),

    {ok, Sup2} = blockchain_sup:start_link([{update_dir, GenDir}|Opts]),
    ?assert(erlang:is_pid(blockchain_swarm:swarm())),

    Chain1 = blockchain_worker:blockchain(),
    {ok, HeadBlock1} = blockchain:head_block(Chain1),
    ?assertEqual(blockchain_block:hash_block(LastBlock), blockchain_block:hash_block(HeadBlock1)),
    ?assertEqual({ok, LastBlock}, blockchain:head_block(Chain1)),
    ?assertEqual({ok, blockchain_block:hash_block(GenBlock)}, blockchain:genesis_hash(Chain1)),
    ?assertEqual({ok, GenBlock}, blockchain:genesis_block(Chain1)),
    ?assertEqual({ok, 11}, blockchain:height(Chain1)),

    true = erlang:exit(Sup2, normal),
    ok.


htlc_payee_redeem_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    PubKey = ?config(pubkey, Config),
    PrivKey = ?config(privkey, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    % Create a Payer
    Payer = libp2p_crypto:pubkey_to_bin(PubKey),
    % Create a Payee
    #{public := PayeePubKey, secret := PayeePrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Payee = libp2p_crypto:pubkey_to_bin(PayeePubKey),
    % Generate a random address
    HTLCAddress = crypto:strong_rand_bytes(33),
    % Create a Hashlock
    Hashlock = crypto:hash(sha256, <<"sharkfed">>),
    CreateTx = blockchain_txn_create_htlc_v1:new(Payer, Payee, HTLCAddress, Hashlock, 3, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    SignedCreateTx = blockchain_txn_create_htlc_v1:sign(CreateTx, SigFun),

    %% confirm the txns passes validations
    ?assertEqual(ok, blockchain_txn_create_htlc_v1:is_valid(SignedCreateTx, Chain)),

    % send some money to the payee so they have enough to pay the fee for redeeming
    Tx = blockchain_txn_payment_v1:new(Payer, Payee, 100, 0, 2),
    SigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),

    %% these transactions depend on each other, but they should be able to exist in the same block
    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedCreateTx, SignedTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    {ok, HeadHash} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block), HeadHash),
    ?assertEqual({ok, Block}, blockchain:get_block(HeadHash, Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),

    % Check that the Payer balance has been reduced by 2500
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Payer, blockchain:ledger(Chain)),
    ?assertEqual(Balance - 2600, blockchain_ledger_entry_v1:balance(NewEntry0)),

    % Check that the HLTC address exists and has the correct balance, hashlock and timelock
    % NewHTLC0 = blockchain_ledger_v1:find_htlc(HTLCAddress, blockchain:ledger(Chain)),
    {ok, NewHTLC0} = blockchain_ledger_v1:find_htlc(HTLCAddress, blockchain:ledger(Chain)),
    ?assertEqual(2500, blockchain_ledger_htlc_v1:balance(NewHTLC0)),
    ?assertEqual(Hashlock, blockchain_ledger_htlc_v1:hashlock(NewHTLC0)),
    ?assertEqual(3, blockchain_ledger_htlc_v1:timelock(NewHTLC0)),

    % Try and redeem
    RedeemSigFun = libp2p_crypto:mk_sig_fun(PayeePrivKey),
    RedeemTx = blockchain_txn_redeem_htlc_v1:new(Payee, HTLCAddress, <<"sharkfed">>, 0),
    SignedRedeemTx = blockchain_txn_redeem_htlc_v1:sign(RedeemTx, RedeemSigFun),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [SignedRedeemTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),
    timer:sleep(500), %% add block is a cast, need some time for this to happen

    % Check that the second block with the Redeem TX was mined properly
    {ok, HeadHash2} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block2), HeadHash2),
    ?assertEqual({ok, Block2}, blockchain:get_block(HeadHash2, Chain)),
    ?assertEqual({ok, 3}, blockchain:height(Chain)),

    % Check that the Payee now owns 2500
    {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payee, blockchain:ledger(Chain)),
    ?assertEqual(2600, blockchain_ledger_entry_v1:balance(NewEntry1)),

    % confirm the replay of the previously absorbed txn fails validations
    % as we are reusing the same nonce
    ?assertEqual({error,{bad_nonce,{create_htlc,1,3}}}, blockchain_txn_create_htlc_v1:is_valid(SignedCreateTx, Chain)),
    ok.

htlc_payer_redeem_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    PubKey = ?config(pubkey, Config),
    PrivKey = ?config(privkey, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    % Create a Payer
    Payer = libp2p_crypto:pubkey_to_bin(PubKey),
    % Generate a random address
    HTLCAddress = crypto:strong_rand_bytes(33),
    % Create a Hashlock
    Hashlock = crypto:hash(sha256, <<"sharkfed">>),
    CreateTx = blockchain_txn_create_htlc_v1:new(Payer, Payer, HTLCAddress, Hashlock, 3, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    SignedCreateTx = blockchain_txn_create_htlc_v1:sign(CreateTx, SigFun),

    %% confirm the txns passes validations
    ?assertEqual(ok, blockchain_txn_create_htlc_v1:is_valid(SignedCreateTx, Chain)),

    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedCreateTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    {ok, HeadHash} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block), HeadHash),
    ?assertEqual({ok, Block}, blockchain:get_block(HeadHash, Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),

    % Check that the Payer balance has been reduced by 2500
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Payer, blockchain:ledger(Chain)),
    ?assertEqual(Balance - 2500, blockchain_ledger_entry_v1:balance(NewEntry0)),

    % Check that the HLTC address exists and has the correct balance, hashlock and timelock
    % NewHTLC0 = blockchain_ledger_v1:find_htlc(HTLCAddress, blockchain:ledger(Chain)),
    {ok, NewHTLC0} = blockchain_ledger_v1:find_htlc(HTLCAddress, blockchain:ledger(Chain)),
    ?assertEqual(2500, blockchain_ledger_htlc_v1:balance(NewHTLC0)),
    ?assertEqual(Hashlock, blockchain_ledger_htlc_v1:hashlock(NewHTLC0)),
    ?assertEqual(3, blockchain_ledger_htlc_v1:timelock(NewHTLC0)),

    % Mine another couple of blocks
    {ok, Block2} = test_utils:create_block(ConsensusMembers, []),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),
    {ok, Block3} = test_utils:create_block(ConsensusMembers, []),
    _ = blockchain_gossip_handler:add_block(Swarm, Block3, Chain, self()),
    timer:sleep(500), %% add block is a cast, need some time for this to happen

    % Check we are at height 4
    {ok, HeadHash2} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block3), HeadHash2),
    ?assertEqual({ok, Block3}, blockchain:get_block(HeadHash2, Chain)),
    ?assertEqual({ok, 4}, blockchain:height(Chain)),

    ?assertEqual({ok, 4}, blockchain_ledger_v1:current_height(blockchain:ledger(Chain))),

    % Try and redeem
    RedeemTx = blockchain_txn_redeem_htlc_v1:new(Payer, HTLCAddress, <<"sharkfed">>, 0),
    SigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    SignedRedeemTx = blockchain_txn_redeem_htlc_v1:sign(RedeemTx, SigFun),
    {ok, Block4} = test_utils:create_block(ConsensusMembers, [SignedRedeemTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block4, Chain, self()),

    % Check that the Payer now owns 5000 again
    {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payer, blockchain:ledger(Chain)),
    ?assertEqual(5000, blockchain_ledger_entry_v1:balance(NewEntry1)),

    % confirm the replay of the previously absorbed txn fails validations
    % as we are reusing the same nonce
    ?assertEqual({error,{bad_nonce,{create_htlc,1,2}}}, blockchain_txn_create_htlc_v1:is_valid(SignedCreateTx, Chain)),

    ok.

poc_request_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    PubKey = ?config(pubkey, Config),
    PrivKey = ?config(privkey, Config),
    Owner = libp2p_crypto:pubkey_to_bin(PubKey),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    Balance = ?config(balance, Config),

    Ledger = blockchain:ledger(Chain),
    Rate = 1000000,
    {Priv, _} = ?config(master_key, Config),
    Vars = #{token_burn_exchange_rate => Rate},
    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block2)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block2}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block2}, blockchain:get_block(2, Chain)),
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self())
        end,
        lists:seq(1, 20)
    ),
    ?assertEqual({ok, Rate}, blockchain_ledger_v1:config(?token_burn_exchange_rate, Ledger)),

    % Step 2: Token burn txn should pass now
    OwnerSigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    BurnTx0 = blockchain_txn_token_burn_v1:new(Owner, 10, 1),
    SignedBurnTx0 = blockchain_txn_token_burn_v1:sign(BurnTx0, OwnerSigFun),
    {ok, Block23} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block23, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block23)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block23}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 23}, blockchain:height(Chain)),
    ?assertEqual({ok, Block23}, blockchain:get_block(23, Chain)),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Owner, Ledger),
    ?assertEqual(Balance - 10, blockchain_ledger_entry_v1:balance(NewEntry0)),
    {ok, DCEntry0} = blockchain_ledger_v1:find_dc_entry(Owner, Ledger),
    ?assertEqual(10*Rate, blockchain_ledger_data_credits_entry_v1:balance(DCEntry0)),

    % Create a Gateway
    #{public := GatewayPubKey, secret := GatewayPrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Gateway = libp2p_crypto:pubkey_to_bin(GatewayPubKey),
    GatewaySigFun = libp2p_crypto:mk_sig_fun(GatewayPrivKey),


    % Add a Gateway
    AddGatewayTx = blockchain_txn_add_gateway_v1:new(Owner, Gateway, 1, 1),
    SignedOwnerAddGatewayTx = blockchain_txn_add_gateway_v1:sign(AddGatewayTx, OwnerSigFun),
    SignedGatewayAddGatewayTx = blockchain_txn_add_gateway_v1:sign_request(SignedOwnerAddGatewayTx, GatewaySigFun),
    {ok, Block24} = test_utils:create_block(ConsensusMembers, [SignedGatewayAddGatewayTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block24, Chain, self()),

    {ok, HeadHash} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block24), HeadHash),
    ?assertEqual({ok, Block24}, blockchain:get_block(HeadHash, Chain)),
    ?assertEqual({ok, 24}, blockchain:height(Chain)),

    % Check that the Gateway is there
    {ok, GwInfo} = blockchain_ledger_v1:find_gateway_info(Gateway, blockchain:ledger(Chain)),
    ?assertEqual(Owner, blockchain_ledger_gateway_v2:owner_address(GwInfo)),

    % Assert the Gateways location
    AssertLocationRequestTx = blockchain_txn_assert_location_v1:new(Gateway, Owner, ?TEST_LOCATION, 1, 1, 1),
    PartialAssertLocationTxn = blockchain_txn_assert_location_v1:sign_request(AssertLocationRequestTx, GatewaySigFun),
    SignedAssertLocationTx = blockchain_txn_assert_location_v1:sign(PartialAssertLocationTxn, OwnerSigFun),

    {ok, Block25} = test_utils:create_block(ConsensusMembers, [SignedAssertLocationTx]),
    ok = blockchain_gossip_handler:add_block(Swarm, Block25, Chain, self()),
    timer:sleep(500),

    {ok, HeadHash2} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block25), HeadHash2),
    ?assertEqual({ok, Block25}, blockchain:get_block(HeadHash2, Chain)),
    ?assertEqual({ok, 25}, blockchain:height(Chain)),

    % Create the PoC challenge request txn
    Keys0 = libp2p_crypto:generate_keys(ecc_compact),
    Secret0 = libp2p_crypto:keys_to_bin(Keys0),
    #{public := OnionCompactKey0} = Keys0,
    SecretHash0 = crypto:hash(sha256, Secret0),
    OnionKeyHash0 = crypto:hash(sha256, libp2p_crypto:pubkey_to_bin(OnionCompactKey0)),
    PoCReqTxn0 = blockchain_txn_poc_request_v1:new(Gateway, SecretHash0, OnionKeyHash0, blockchain_block:hash_block(Block2), 1),
    SignedPoCReqTxn0 = blockchain_txn_poc_request_v1:sign(PoCReqTxn0, GatewaySigFun),
    {ok, Block26} = test_utils:create_block(ConsensusMembers, [SignedPoCReqTxn0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block26, Chain, self()),
    ok = blockchain_ct_utils:wait_until(fun() -> {ok, 26} =:= blockchain:height(Chain) end),

    Ledger = blockchain:ledger(Chain),
    {ok, HeadHash3} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block26), HeadHash3),
    ?assertEqual({ok, Block26}, blockchain:get_block(HeadHash3, Chain)),
    % Check that the last_poc_challenge block height got recorded in GwInfo
    {ok, GwInfo2} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    ?assertEqual(26, blockchain_ledger_gateway_v2:last_poc_challenge(GwInfo2)),
    ?assertEqual(OnionKeyHash0, blockchain_ledger_gateway_v2:last_poc_onion_key_hash(GwInfo2)),

    % Check that the PoC info
    {ok, [PoC]} = blockchain_ledger_v1:find_poc(OnionKeyHash0, Ledger),
    ?assertEqual(SecretHash0, blockchain_ledger_poc_v2:secret_hash(PoC)),
    ?assertEqual(OnionKeyHash0, blockchain_ledger_poc_v2:onion_key_hash(PoC)),
    ?assertEqual(Gateway, blockchain_ledger_poc_v2:challenger(PoC)),

    meck:new(blockchain_txn_poc_receipts_v1, [passthrough]),
    meck:expect(blockchain_txn_poc_receipts_v1, is_valid, fun(_Txn, _Chain) -> ok end),

    PoCReceiptsTxn = blockchain_txn_poc_receipts_v1:new(Gateway, Secret0, OnionKeyHash0, []),
    SignedPoCReceiptsTxn = blockchain_txn_poc_receipts_v1:sign(PoCReceiptsTxn, GatewaySigFun),
    {ok, Block27} = test_utils:create_block(ConsensusMembers, [SignedPoCReceiptsTxn]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block27, Chain, self()),
    ok = blockchain_ct_utils:wait_until(fun() -> {ok, 27} =:= blockchain:height(Chain) end),

    Block62 = lists:foldl(
        fun(_, _) ->
                {ok, B} = test_utils:create_block(ConsensusMembers, []),
            _ = blockchain_gossip_handler:add_block(Swarm, B, Chain, self()),
            timer:sleep(10),
            B
        end,
        <<>>,
        lists:seq(1, 35)
    ),

    ok = blockchain_ct_utils:wait_until(fun() -> {ok, 62} =:= blockchain:height(Chain) end),

    % Create another PoC challenge request txn
    Keys1 = libp2p_crypto:generate_keys(ecc_compact),
    Secret1 = libp2p_crypto:keys_to_bin(Keys1),
    #{public := OnionCompactKey1} = Keys1,
    SecretHash1 = crypto:hash(sha256, Secret1),
    OnionKeyHash1 = crypto:hash(sha256, libp2p_crypto:pubkey_to_bin(OnionCompactKey1)),
    PoCReqTxn1 = blockchain_txn_poc_request_v1:new(Gateway, SecretHash1, OnionKeyHash1, blockchain_block:hash_block(Block62), 1),
    SignedPoCReqTxn1 = blockchain_txn_poc_request_v1:sign(PoCReqTxn1, GatewaySigFun),
    {ok, Block63} = test_utils:create_block(ConsensusMembers, [SignedPoCReqTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block63, Chain, self()),

    ok = blockchain_ct_utils:wait_until(fun() -> {ok, 63} =:= blockchain:height(Chain) end),

    ?assertEqual({error, not_found}, blockchain_ledger_v1:find_poc(OnionKeyHash0, Ledger)),
    % Check that the last_poc_challenge block height got recorded in GwInfo
    {ok, GwInfo3} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    ?assertEqual(63, blockchain_ledger_gateway_v2:last_poc_challenge(GwInfo3)),
    ?assertEqual(OnionKeyHash1, blockchain_ledger_gateway_v2:last_poc_onion_key_hash(GwInfo3)),

    ?assert(meck:validate(blockchain_txn_poc_receipts_v1)),
    meck:unload(blockchain_txn_poc_receipts_v1),
    ok.

bogus_coinbase_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    [{FirstMemberAddr, _} | _] = ConsensusMembers,
    Chain = ?config(chain, Config),

    ?assertEqual({ok, 1}, blockchain:height(Chain)),

    %% Lets give the first member a bunch of coinbase tokens
    BogusCoinbaseTxn = blockchain_txn_coinbase_v1:new(FirstMemberAddr, 999999),

    %% This should error out cuz this is an invalid txn
    {error, {invalid_txns, [BogusCoinbaseTxn]}} = test_utils:create_block(ConsensusMembers, [BogusCoinbaseTxn]),

    ?assertEqual({ok, 1}, blockchain:height(Chain)),

    ok.

bogus_coinbase_with_good_payment_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    [{FirstMemberAddr, _} | _] = ConsensusMembers,
    Chain = ?config(chain, Config),

    %% Lets give the first member a bunch of coinbase tokens
    BogusCoinbaseTxn = blockchain_txn_coinbase_v1:new(FirstMemberAddr, 999999),

    %% Create a good payment transaction as well
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedGoodPaymentTxn = blockchain_txn_payment_v1:sign(Tx, SigFun),

    %% This should error out cuz this is an invalid txn
    {error, {invalid_txns, [BogusCoinbaseTxn]}} = test_utils:create_block(ConsensusMembers,
                                                                          [BogusCoinbaseTxn, SignedGoodPaymentTxn]),
    %% Check that the chain didnt' grow
    ?assertEqual({ok, 1}, blockchain:height(Chain)),

    ok.

export_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    GenesisMembers = ?config(genesis_members, Config),
    Balance = ?config(balance, Config),
    [_,
     {Payer1, {PayerPubKey1, PayerPrivKey1, _}},
     {Payer2, {_, PayerPrivKey2, _}},
     {Payer3, {_, PayerPrivKey3, _}}
     | _] = ConsensusMembers,
    Amount = 2500,
    Fee = 0,
    N = length(ConsensusMembers),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    N = ?config(n, Config),

    Ledger = blockchain:ledger(Chain),
    Rate = 1000000,
    {Priv, _} = ?config(master_key, Config),
    Vars = #{token_burn_exchange_rate => Rate},
    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block2)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block2}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block2}, blockchain:get_block(2, Chain)),
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self())
        end,
        lists:seq(1, 20)
    ),
    ?assertEqual({ok, Rate}, blockchain_ledger_v1:config(?token_burn_exchange_rate, Ledger)),

    Owner = libp2p_crypto:pubkey_to_bin(PayerPubKey1),
    OwnerSigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey1),

    % Step 2: Token burn txn should pass now
    BurnTx0 = blockchain_txn_token_burn_v1:new(Owner, 10, 1),
    SignedBurnTx0 = blockchain_txn_token_burn_v1:sign(BurnTx0, OwnerSigFun),
    {ok, Block23} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block23, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block23)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block23}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 23}, blockchain:height(Chain)),
    ?assertEqual({ok, Block23}, blockchain:get_block(23, Chain)),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Owner, Ledger),
    ?assertEqual(Balance - 10, blockchain_ledger_entry_v1:balance(NewEntry0)),
    {ok, DCEntry0} = blockchain_ledger_v1:find_dc_entry(Owner, Ledger),
    ?assertEqual(10*Rate, blockchain_ledger_data_credits_entry_v1:balance(DCEntry0)),

    % Create a Gateway
    #{public := GatewayPubKey, secret := GatewayPrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Gateway = libp2p_crypto:pubkey_to_bin(GatewayPubKey),
    GatewaySigFun = libp2p_crypto:mk_sig_fun(GatewayPrivKey),

    % Add a Gateway
    AddGatewayTx = blockchain_txn_add_gateway_v1:new(Owner, Gateway, 1, 0),
    SignedOwnerAddGatewayTx = blockchain_txn_add_gateway_v1:sign(AddGatewayTx, OwnerSigFun),
    SignedGatewayAddGatewayTx = blockchain_txn_add_gateway_v1:sign_request(SignedOwnerAddGatewayTx, GatewaySigFun),

    % Assert the Gateways location
    AssertLocationRequestTx = blockchain_txn_assert_location_v1:new(Gateway, Owner, ?TEST_LOCATION, 1, 1, 0),
    PartialAssertLocationTxn = blockchain_txn_assert_location_v1:sign_request(AssertLocationRequestTx, GatewaySigFun),
    SignedAssertLocationTx = blockchain_txn_assert_location_v1:sign(PartialAssertLocationTxn, OwnerSigFun),

    %% adding the gateway and asserting a location depend on each other, but they should be able to appear in the same block
    PaymentTxn1 = test_utils:create_payment_transaction(Payer1, PayerPrivKey1, Amount, Fee, 2, blockchain_swarm:pubkey_bin()),
    PaymentTxn2 = test_utils:create_payment_transaction(Payer2, PayerPrivKey2, Amount, Fee, 1, blockchain_swarm:pubkey_bin()),
    PaymentTxn3 = test_utils:create_payment_transaction(Payer3, PayerPrivKey3, Amount, Fee, 1, blockchain_swarm:pubkey_bin()),
    Txns0 = [SignedAssertLocationTx, PaymentTxn2, SignedGatewayAddGatewayTx, PaymentTxn1, PaymentTxn3],
    Txns1 = lists:sort(fun blockchain_txn:sort/2, Txns0),
    {ok, Block24} = test_utils:create_block(ConsensusMembers, Txns1),
    _ = blockchain_gossip_handler:add_block(Swarm, Block24, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block24)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block24}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 24}, blockchain:height(Chain)),
    ?assertEqual({ok, Block24}, blockchain:get_block(24, Chain)),
    {ok, GwInfo} = blockchain_ledger_v1:find_gateway_info(Gateway, blockchain:ledger(Chain)),
    ?assertEqual(Owner, blockchain_ledger_gateway_v2:owner_address(GwInfo)),

    timer:sleep(500),

    [{securities, Securities},
     {accounts, Accounts},
     {gateways, Gateways},
     {chain_vars, ChainVars},
     {dcs, DCs}
    ] = blockchain_ledger_exporter_v1:export(blockchain:ledger(Chain)),

    ct:pal("gateways ~p", [Gateways]),

    %% check DC balance for Payer1
    [[{address, A}, {dc_balance, DCBalance}]] = DCs,
    ?assertEqual(A, libp2p_crypto:bin_to_b58(Payer1)),
    ?assertEqual(DCBalance, Rate*10-2),

    %% we added this after we add all of the existing gateways in the
    %% genesis block with nonce 0.  we filter those out to make sure
    %% we're still getting the txn that we're looking for
    Gateways1 = [G || [_, _, _, {nonce, Nonce}] = G <- Gateways, Nonce == 1],

    ?assertEqual([[{gateway_address, libp2p_crypto:pubkey_to_b58(GatewayPubKey)},
                   {owner_address, libp2p_crypto:pubkey_to_b58(PayerPubKey1)},
                   {location,?TEST_LOCATION},
                   {nonce,1}]], Gateways1),

    FilteredExportedAccounts = lists:foldl(fun(Account, Acc) ->
                                                   AccountAddress = proplists:get_value(address, Account),
                                                   case libp2p_crypto:bin_to_b58(Payer1) == AccountAddress orelse
                                                        libp2p_crypto:bin_to_b58(Payer2) == AccountAddress orelse
                                                        libp2p_crypto:bin_to_b58(Payer3) == AccountAddress
                                                   of
                                                       true -> [Account | Acc];
                                                       false -> Acc
                                                   end
                                           end, [], Accounts),
    lists:all(fun(Account) ->
                      (Balance - Amount - Fee) == proplists:get_value(balance, Account)
              end, FilteredExportedAccounts),

    %% check all genesis members are included in the exported securities
    ?assertEqual(length(Securities), length(GenesisMembers)),

    %% check security balance for each member
    lists:all(fun(Security) ->
                      Token = proplists:get_value(token, Security),
                      Token == Balance
              end, Securities),

    InitVars0 = blockchain_ct_utils:raw_vars(#{token_burn_exchange_rate => Rate}),

    InitVars = lists:sort(
                 lists:map(fun({Atom, Val}) ->
                                   {atom_to_binary(Atom, utf8), Val}
                           end,
                           maps:to_list(InitVars0))),

    ?assertEqual([], ChainVars -- InitVars),
    ?assertEqual([], InitVars -- ChainVars),

    ok.


delayed_ledger_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    Balance = ?config(balance, Config),

    Ledger = blockchain:ledger(Chain),
    ?assertEqual({ok, 1}, blockchain_ledger_v1:current_height(Ledger)),

    DelayedLedger = blockchain_ledger_v1:mode(delayed, Ledger),
    ?assertEqual({ok, 1}, blockchain_ledger_v1:current_height(DelayedLedger)),

        % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Payee = blockchain_swarm:pubkey_bin(),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),

    lists:foreach(
        fun(X) ->
            Tx = blockchain_txn_payment_v1:new(Payer, Payee, 1, 0, X),
            SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),
            {ok, B} = test_utils:create_block(ConsensusMembers, [SignedTx]),
            _ = blockchain_gossip_handler:add_block(Swarm, B, Chain, self())
        end,
        lists:seq(1, 100)
    ),

    % Check heights of Ledger and delayed ledger should be 50 block behind
    ?assertEqual({ok, 101}, blockchain_ledger_v1:current_height(Ledger)),
    ?assertEqual({ok, 51}, blockchain_ledger_v1:current_height(DelayedLedger)),

    % Check balances of payer and payee in edger
    {ok, Entry1} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 100, blockchain_ledger_entry_v1:balance(Entry1)),

    {ok, Entry2} = blockchain_ledger_v1:find_entry(Payee, Ledger),
    ?assertEqual(Balance + 100, blockchain_ledger_entry_v1:balance(Entry2)),

    % Check balances of payer and payee in  delayed ledger
    {ok, Entry3} = blockchain_ledger_v1:find_entry(Payer, DelayedLedger),
    ?assertEqual(Balance - 50, blockchain_ledger_entry_v1:balance(Entry3)),

    {ok, Entry4} = blockchain_ledger_v1:find_entry(Payee, DelayedLedger),
    ?assertEqual(Balance + 50, blockchain_ledger_entry_v1:balance(Entry4)),

    % Same as above except receting context/cache
    {ok, Entry1} = blockchain_ledger_v1:find_entry(Payer, blockchain_ledger_v1:new_context(Ledger)),
    ?assertEqual(Balance - 100, blockchain_ledger_entry_v1:balance(Entry1)),

    {ok, Entry2} = blockchain_ledger_v1:find_entry(Payee, blockchain_ledger_v1:new_context(Ledger)),
    ?assertEqual(Balance + 100, blockchain_ledger_entry_v1:balance(Entry2)),

    {ok, Entry3} = blockchain_ledger_v1:find_entry(Payer, blockchain_ledger_v1:new_context(DelayedLedger)),
    ?assertEqual(Balance - 50, blockchain_ledger_entry_v1:balance(Entry3)),

    {ok, Entry4} = blockchain_ledger_v1:find_entry(Payee, blockchain_ledger_v1:new_context(DelayedLedger)),
    ?assertEqual(Balance + 50, blockchain_ledger_entry_v1:balance(Entry4)),

    % We should not allow to query prior delayed ledger and obviously neither in the futur
    ?assertEqual({error, height_too_old}, blockchain:ledger_at(50, Chain)),
    ?assertEqual({error, invalid_height}, blockchain:ledger_at(107, Chain)),

    % Now lets go forward a block & check balances again
    {ok, LedgerAt} = blockchain:ledger_at(100, Chain),

    {ok, Entry5} = blockchain_ledger_v1:find_entry(Payer, LedgerAt),
    ?assertEqual(Balance - 99, blockchain_ledger_entry_v1:balance(Entry5)),

    {ok, Entry6} = blockchain_ledger_v1:find_entry(Payee, LedgerAt),
    ?assertEqual(Balance + 99, blockchain_ledger_entry_v1:balance(Entry6)),

     % Check balances of payer and payee in  delayed ledger again making sure context did not explode
    {ok, Entry3} = blockchain_ledger_v1:find_entry(Payer, DelayedLedger),
    ?assertEqual(Balance - 50, blockchain_ledger_entry_v1:balance(Entry3)),

    {ok, Entry4} = blockchain_ledger_v1:find_entry(Payee, DelayedLedger),
    ?assertEqual(Balance + 50, blockchain_ledger_entry_v1:balance(Entry4)),
    ok.

fees_since_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Payee = blockchain_swarm:pubkey_bin(),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),

    meck:new(blockchain_ledger_v1, [passthrough]),
    meck:expect(blockchain_ledger_v1, check_dc_balance, fun(_, _, _) -> ok end),
    meck:expect(blockchain_ledger_v1, debit_fee, fun(_, _, _) -> ok end),

    % Add 100 txns with 1 fee each
    lists:foreach(
        fun(X) ->
            Tx = blockchain_txn_payment_v1:new(Payer, Payee, 1, 1, X),
            SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),
            {ok, B} = test_utils:create_block(ConsensusMembers, [SignedTx]),
            _ = blockchain_gossip_handler:add_block(Swarm, B, Chain, self())
        end,
        lists:seq(1, 100)
    ),

    ?assertEqual({error, bad_height}, blockchain:fees_since(100000, Chain)),
    ?assertEqual({error, bad_height}, blockchain:fees_since(1, Chain)),
    ?assertEqual({ok, 100}, blockchain:fees_since(2, Chain)),
    ?assert(meck:validate(blockchain_ledger_v1)),
    meck:unload(blockchain_ledger_v1).

security_token_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Tx = blockchain_txn_security_exchange_v1:new(Payer, Recipient, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_security_exchange_v1:sign(Tx, SigFun),
    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedTx]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),

    ?assertEqual({ok, Block}, blockchain:get_block(2, Chain)),

    Ledger = blockchain:ledger(Chain),
    {ok, NewEntry0} = blockchain_ledger_v1:find_security_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500, blockchain_ledger_security_entry_v1:balance(NewEntry0)),

    {ok, NewEntry1} = blockchain_ledger_v1:find_security_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500, blockchain_ledger_security_entry_v1:balance(NewEntry1)),
    ok.

routing_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    Ledger = blockchain:ledger(Chain),

    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),

    meck:new(blockchain_txn_oui_v1, [no_link, passthrough]),
    meck:expect(blockchain_txn_oui_v1, is_valid, fun(_, _) -> ok end),

    OUI1 = 1,
    Addresses0 = [libp2p_swarm:pubkey_bin(Swarm)],
    {Filter, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn0 = blockchain_txn_oui_v1:new(Payer, Addresses0, Filter, 8, 0, 0),
    SignedOUITxn0 = blockchain_txn_oui_v1:sign(OUITxn0, SigFun),

    ?assertEqual({error, not_found}, blockchain_ledger_v1:find_routing(OUI1, Ledger)),

    {ok, Block0} = test_utils:create_block(ConsensusMembers, [SignedOUITxn0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block0, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 2} == blockchain:height(Chain) end),

    Routing0 = blockchain_ledger_routing_v1:new(OUI1, Payer, Addresses0, Filter,
                                                <<0:25/integer-unsigned-big, (blockchain_ledger_v1:subnet_size_to_mask(8)):23/integer-unsigned-big>>, 0),
    ?assertEqual({ok, Routing0}, blockchain_ledger_v1:find_routing(OUI1, Ledger)),

    #{public := NewPubKey, secret := _PrivKey} = libp2p_crypto:generate_keys(ed25519),
    Addresses1 = [libp2p_crypto:pubkey_to_bin(NewPubKey)],
    OUITxn2 = blockchain_txn_routing_v1:update_router_addresses(OUI1, Payer, Addresses1, 0, 1),
    SignedOUITxn2 = blockchain_txn_routing_v1:sign(OUITxn2, SigFun),
    {ok, Block1} = test_utils:create_block(ConsensusMembers, [SignedOUITxn2]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block1, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 3} == blockchain:height(Chain) end),

    Routing1 = blockchain_ledger_routing_v1:new(OUI1, Payer, Addresses1, Filter,
                                                <<0:25/integer-unsigned-big, (blockchain_ledger_v1:subnet_size_to_mask(8)):23/integer-unsigned-big>>, 1),
    ?assertEqual({ok, Routing1}, blockchain_ledger_v1:find_routing(OUI1, Ledger)),

    OUITxn3 = blockchain_txn_routing_v1:request_subnet(OUI1, Payer, 32, 0, 2),
    SignedOUITxn3 = blockchain_txn_routing_v1:sign(OUITxn3, SigFun),
    {Filter2, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn4 = blockchain_txn_routing_v1:update_xor(OUI1, Payer, 0, Filter2, 0, 3),
    SignedOUITxn4 = blockchain_txn_routing_v1:sign(OUITxn4, SigFun),
    {Filter2a, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn4a = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter2a, 0, 4),
    SignedOUITxn4a = blockchain_txn_routing_v1:sign(OUITxn4a, SigFun),

    {ok, Block2} = test_utils:create_block(ConsensusMembers, [SignedOUITxn3, SignedOUITxn4, SignedOUITxn4a]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 4} == blockchain:height(Chain) end),

    {ok, Routing2} = blockchain_ledger_v1:find_routing(OUI1, Ledger),
    %Routing2 = blockchain_ledger_routing_v1:new(OUI1, Payer, Addresses1, Filter2, <<0,0,0,127,255,254>>, 3),
    ?assertEqual([<<0:25/integer-unsigned-big, (blockchain_ledger_v1:subnet_size_to_mask(8)):23/integer-unsigned-big>>,
                  <<32:25/integer-unsigned-big, (blockchain_ledger_v1:subnet_size_to_mask(32)):23/integer-unsigned-big>>],
                 blockchain_ledger_routing_v1:subnets(Routing2)),
    ?assertEqual([Filter2, Filter2a], blockchain_ledger_routing_v1:filters(Routing2)),
    ?assertEqual(4, blockchain_ledger_routing_v1:nonce(Routing2)),

    %% test updating with invalid filter
    Filter3 = <<"lolsdf">>,
    OUITxn5 = blockchain_txn_routing_v1:update_xor(OUI1, Payer, 0, Filter3, 0, 5),
    SignedOUITxn5 = blockchain_txn_routing_v1:sign(OUITxn5, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn5]),

    Filter4 = crypto:strong_rand_bytes(1024*1024),
    OUITxn6 = blockchain_txn_routing_v1:update_xor(OUI1, Payer, 0, Filter4, 0, 5),
    SignedOUITxn6 = blockchain_txn_routing_v1:sign(OUITxn6, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn6]),

    OUITxn6a = blockchain_txn_routing_v1:update_xor(OUI1, Payer, 2, Filter, 0, 5),
    SignedOUITxn6a = blockchain_txn_routing_v1:sign(OUITxn6a, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn6a]),

    OUITxn6b = blockchain_txn_routing_v1:update_xor(OUI1, Payer, 5, Filter, 0, 5),
    SignedOUITxn6b = blockchain_txn_routing_v1:sign(OUITxn6b, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn6b]),

    %% test invalid subnet_size
    OUITxn7 = blockchain_txn_routing_v1:request_subnet(OUI1, Payer, 31, 0, 5),
    SignedOUITxn7 = blockchain_txn_routing_v1:sign(OUITxn7, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn7]),
    OUITxn8 = blockchain_txn_routing_v1:request_subnet(OUI1, Payer, 2, 0, 5),
    SignedOUITxn8 = blockchain_txn_routing_v1:sign(OUITxn8, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn8]),
    OUITxn9 = blockchain_txn_routing_v1:request_subnet(OUI1, Payer, 4294967296, 0, 5),
    SignedOUITxn9 = blockchain_txn_routing_v1:sign(OUITxn9, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn9]),

    %% test adding an invalid xor
    OUITxn10 = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter3, 0, 5),
    SignedOUITxn10 = blockchain_txn_routing_v1:sign(OUITxn10, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn10]),
    OUITxn11 = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter4, 0, 5),
    SignedOUITxn11 = blockchain_txn_routing_v1:sign(OUITxn11, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn11]),

    %% fill up the xor list for this node
    {Filter2b, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn4b = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter2b, 0, 5),
    SignedOUITxn4b = blockchain_txn_routing_v1:sign(OUITxn4b, SigFun),

    {Filter2c, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn4c = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter2c, 0, 6),
    SignedOUITxn4c = blockchain_txn_routing_v1:sign(OUITxn4c, SigFun),

    {Filter2d, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn4d = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter2d, 0, 7),
    SignedOUITxn4d = blockchain_txn_routing_v1:sign(OUITxn4d, SigFun),

    {ok, Block3} = test_utils:create_block(ConsensusMembers, [SignedOUITxn4b, SignedOUITxn4c, SignedOUITxn4d]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block3, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 5} == blockchain:height(Chain) end),

    {ok, Routing3} = blockchain_ledger_v1:find_routing(OUI1, Ledger),
    %Routing2 = blockchain_ledger_routing_v1:new(OUI1, Payer, Addresses1, Filter2, <<0,0,0,127,255,254>>, 3),
    ?assertEqual([<<0:25/integer-unsigned-big, (blockchain_ledger_v1:subnet_size_to_mask(8)):23/integer-unsigned-big>>,
                  <<32:25/integer-unsigned-big, (blockchain_ledger_v1:subnet_size_to_mask(32)):23/integer-unsigned-big>>],
                 blockchain_ledger_routing_v1:subnets(Routing3)),
    ?assertEqual([Filter2, Filter2a, Filter2b, Filter2c, Filter2d], blockchain_ledger_routing_v1:filters(Routing3)),
    ?assertEqual(7, blockchain_ledger_routing_v1:nonce(Routing3)),

    %% no more filters can be added
    {Filter2e, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn4e = blockchain_txn_routing_v1:new_xor(OUI1, Payer, Filter2e, 0, 8),
    SignedOUITxn4e = blockchain_txn_routing_v1:sign(OUITxn4e, SigFun),
    {error, {invalid_txns, _}} = test_utils:create_block(ConsensusMembers, [SignedOUITxn4e]),

    OUI2 = 2,
    Addresses0 = [libp2p_swarm:pubkey_bin(Swarm)],
    OUITxn01 = blockchain_txn_oui_v1:new(Payer, Addresses0, Filter, 8, 0, 0),
    SignedOUITxn01 = blockchain_txn_oui_v1:sign(OUITxn01, SigFun),

    ?assertEqual({error, not_found}, blockchain_ledger_v1:find_routing(OUI2, Ledger)),

    {ok, Block4} = test_utils:create_block(ConsensusMembers, [SignedOUITxn01]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block4, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 6} == blockchain:height(Chain) end),

    Routing4 = blockchain_ledger_routing_v1:new(OUI2, Payer, Addresses0, Filter, <<0,0,4,127,255,254>>, 0),
    ?assertEqual({ok, Routing4}, blockchain_ledger_v1:find_routing(OUI2, Ledger)),

    ?assertEqual({ok, [2, 1]}, blockchain_ledger_v1:find_ouis(Payer, Ledger)),

    ?assert(meck:validate(blockchain_txn_oui_v1)),
    meck:unload(blockchain_txn_oui_v1),
    ok.

block_save_failed_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

     % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),
    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedTx]),
    {ok, OldHeight} = blockchain:height(Chain),
    meck:new(blockchain, [passthrough]),
    meck:expect(blockchain, save_block, fun(_, _) -> erlang:error(boom) end),
    {ok, OldHeight} = blockchain:height(Chain),
    blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
    meck:unload(blockchain),
    blockchain_lock:release(),
    ok = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
    {ok, NewHeight} = blockchain:height(Chain),
    ?assert(NewHeight == OldHeight + 1),

     ?assertEqual({ok, blockchain_block:hash_block(Block)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),

     ?assertEqual({ok, Block}, blockchain:get_block(2, Chain)),

     Ledger = blockchain:ledger(Chain),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500, blockchain_ledger_entry_v1:balance(NewEntry0)),

     {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500, blockchain_ledger_entry_v1:balance(NewEntry1)),
    ok.

absorb_failed_test(Config) ->
    BaseDir = ?config(base_dir, Config),
    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),
    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedTx]),
    meck:new(blockchain, [passthrough]),
    meck:expect(blockchain, save_block, fun(B, C) ->
        meck:passthrough([B, C]),
        ct:pal("BOOM"),
        erlang:error(boom)
    end),
    blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
    meck:unload(blockchain),
    Ledger = blockchain:ledger(Chain),

    ?assertEqual({ok, blockchain_block:hash_block(Block)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, 1}, blockchain_ledger_v1:current_height(Ledger)),
    ?assertEqual({ok, Block}, blockchain:get_block(2, Chain)),

    ct:pal("Try to re-add block 1 will cause the mismatch"),
    ok = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain:height(Chain) end),
    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain_ledger_v1:current_height(Ledger) end),

    ct:pal("Try to re-add block 2"),
    ok = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain:height(Chain) end),
    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain_ledger_v1:current_height(Ledger) end),

    ?assertEqual({ok, blockchain_block:hash_block(Block)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block}, blockchain:get_block(2, Chain)),

    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500, blockchain_ledger_entry_v1:balance(NewEntry0)),

    {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500, blockchain_ledger_entry_v1:balance(NewEntry1)),
    ok.

missing_last_block_test(Config) ->
    BaseDir = ?config(base_dir, Config),
    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, 2500, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),
    {ok, Block} = test_utils:create_block(ConsensusMembers, [SignedTx]),
    meck:new(blockchain, [passthrough]),
    meck:expect(blockchain, save_block, fun(_B, _C) ->
            %% just don't save it
            ok
    end),
    blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
    meck:unload(blockchain),
    Ledger = blockchain:ledger(Chain),
    {ok, GenesisBlock} = blockchain:genesis_block(Chain),

    ?assertEqual({ok, blockchain_block:hash_block(GenesisBlock)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, GenesisBlock}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 1}, blockchain:height(Chain)),
    ?assertEqual({ok, 2}, blockchain_ledger_v1:current_height(Ledger)),
    ?assertEqual({error, not_found}, blockchain:get_block(2, Chain)),

    ct:pal("Try to re-add block 1 will cause the mismatch"),
    ok = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain:height(Chain) end),
    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain_ledger_v1:current_height(Ledger) end),

    ct:pal("Try to re-add block 2"),
    ok = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),

    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain:height(Chain) end),
    ok = test_utils:wait_until(fun() -> {ok, 2} =:= blockchain_ledger_v1:current_height(Ledger) end),

    ?assertEqual({ok, blockchain_block:hash_block(Block)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block}, blockchain:get_block(2, Chain)),

    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500, blockchain_ledger_entry_v1:balance(NewEntry0)),

    {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500, blockchain_ledger_entry_v1:balance(NewEntry1)),
    ok.

epoch_reward_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    [_, {PubKeyBin, {_, _PrivKey, _}}|_] = ConsensusMembers,

    meck:new(blockchain_txn_poc_receipts_v1, [passthrough]),
    meck:expect(blockchain_txn_poc_receipts_v1, is_valid, fun(_Txn, _Chain) -> ok end),
    meck:expect(blockchain_txn_poc_receipts_v1, absorb, fun(_Txn, _Chain) -> ok end),

    meck:new(blockchain_txn_consensus_group_v1, [passthrough]),
    meck:expect(blockchain_txn_consensus_group_v1, is_valid, fun(_Txn, _Chain) -> ok end),

    meck:new(blockchain_ledger_v1, [passthrough]),
    meck:expect(blockchain_ledger_v1, find_gateway_info, fun(Address, _Ledger) ->
        {ok, blockchain_ledger_gateway_v2:new(Address, 12)}
    end),

    % Add few empty blocks to fake epoch
    Start = 1,
    End = 30,
    _Blocks = lists:reverse(lists:foldl(
        fun(X, Acc) ->
            Txns = case X =:= 15 of
                false ->
                    [];
                true ->
                    POCReceiptTxn = blockchain_txn_poc_receipts_v1:new(PubKeyBin, <<"Secret">>, <<"OnionKeyHash">>, []),
                    [POCReceiptTxn]
            end,
            {ok, B} = test_utils:create_block(ConsensusMembers, Txns),
            _ = blockchain_gossip_handler:add_block(Swarm, B, Chain, self()),
            [B|Acc]
        end,
        [],
        lists:seq(1, End+2)
    )),
    {ok, Rewards} = blockchain_txn_rewards_v1:calculate_rewards(Start, End, Chain),
    ct:pal("rewards ~p", [Rewards]),
    Tx = blockchain_txn_rewards_v1:new(Start, End, Rewards),
    {ok, B} = test_utils:create_block(ConsensusMembers, [Tx]),
    _ = blockchain_gossip_handler:add_block(Swarm, B, Chain, self()),

    Ledger = blockchain:ledger(Chain),
    {ok, Entry} = blockchain_ledger_v1:find_entry(PubKeyBin, Ledger),

    % 2604167 (poc_challengers) + 552399 (securities) + 248016 (consensus group) + 5000 (initial balance)
    ?assertEqual(3409582, blockchain_ledger_entry_v1:balance(Entry)),

    ?assert(meck:validate(blockchain_txn_poc_receipts_v1)),
    meck:unload(blockchain_txn_poc_receipts_v1),
    ?assert(meck:validate(blockchain_ledger_v1)),
    meck:unload(blockchain_ledger_v1),
    ?assert(meck:validate(blockchain_txn_consensus_group_v1)),
    meck:unload(blockchain_txn_consensus_group_v1).

election_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    %% ConsensusMembers = ?config(consensus_members, Config),
    GenesisMembers = ?config(genesis_members, Config),
    BaseDir = ?config(base_dir, Config),
    %% Chain = ?config(chain, Config),
    Chain = blockchain_worker:blockchain(),
    _Swarm = ?config(swarm, Config),
    N = 7,

    %% make sure our generated alpha & beta values are the same each time
    rand:seed(exs1024s, {1, 2, 234098723564079}),
    Ledger = blockchain:ledger(Chain),

    %% add random alpha and beta to gateways
    Ledger1 = blockchain_ledger_v1:new_context(Ledger),

    [begin
         {ok, I} = blockchain_ledger_v1:find_gateway_info(Addr, Ledger1),
         Alpha = (rand:uniform() * 10.0) + 1.0,
         Beta = (rand:uniform() * 10.0) + 1.0,
         I2 = blockchain_ledger_gateway_v2:set_alpha_beta_delta(Alpha, Beta, 1, I),
         blockchain_ledger_v1:update_gateway(I2, Addr, Ledger1)
     end
     || {Addr, _} <- GenesisMembers],
    ok = blockchain_ledger_v1:commit_context(Ledger1),

    {ok, OldGroup} = blockchain_ledger_v1:consensus_members(Ledger),
    ct:pal("old ~p", [OldGroup]),

    %% generate new group of the same length
    New =  blockchain_election:new_group(Ledger, crypto:hash(sha256, "foo"), N, 0),
    New1 =  blockchain_election:new_group(Ledger, crypto:hash(sha256, "foo"), N, 1000),

    ct:pal("new ~p new1 ~p", [New, New1]),

    ?assertEqual(N, length(New)),
    ?assertEqual(N, length(New1)),

    ?assertNotEqual(OldGroup, New),
    ?assertNotEqual(OldGroup, New1),

    %% confirm that they're sorted by score
    Scored =
        [begin
             {ok, I} = blockchain_ledger_v1:find_gateway_info(Addr, Ledger),
             {_, _, Score} = blockchain_ledger_gateway_v2:score(Addr, I, 1, Ledger),
             {Score, Addr}
         end
         || Addr <- New],

    ct:pal("scored ~p", [Scored]),

    %% no dupes
    ?assertEqual(lists:usort(Scored), lists:sort(Scored)),

    %% TODO: add better tests here

    ?assertEqual(1, length(New -- OldGroup)),

    ok.

election_v3_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    GenesisMembers = ?config(genesis_members, Config),
    BaseDir = ?config(base_dir, Config),
    %% Chain = ?config(chain, Config),
    Chain = blockchain_worker:blockchain(),
    Swarm = ?config(swarm, Config),
    N = 7,

    %% make sure our generated alpha & beta values are the same each time
    rand:seed(exs1024s, {1, 2, 234098723564079}),
    Ledger = blockchain:ledger(Chain),

    %% add random alpha and beta to gateways
    Ledger1 = blockchain_ledger_v1:new_context(Ledger),

    %% give good, equal scores to everyone
    [begin
         {ok, I} = blockchain_ledger_v1:find_gateway_info(Addr, Ledger1),
         Alpha = 20.0,
         Beta = 1.0,
         I2 = blockchain_ledger_gateway_v2:set_alpha_beta_delta(Alpha, Beta, 1, I),
         blockchain_ledger_v1:update_gateway(I2, Addr, Ledger1)
     end
     || {Addr, _} <- GenesisMembers],
    ok = blockchain_ledger_v1:commit_context(Ledger1),

    %% we need to add some blocks here.   they have to have seen
    %% values and bbas.
    %% index 5 will be entirely absent
    %% index 6 will be talking (seen) but missing from bbas (maybe
    %% byzantine, maybe just missing/slow on too many packets to
    %% finish anything)
    %% index 7 will be bba-present, but only partially seen, and
    %% should not be penalized

    %% it's possible to test unseen but bba-present here, but that seems impossible?

    SeenA = maps:from_list([{I, case I of 5 -> false; 7 -> true; _ -> true end}
                            || I <- lists:seq(1, N)]),
    SeenB = maps:from_list([{I, case I of 5 -> false; 7 -> false; _ -> true end}
                            || I <- lists:seq(1, N)]),
    Seen0 = lists:duplicate(4, SeenA) ++ lists:duplicate(2, SeenB),

    BBA0 = maps:from_list([{I, case I of 5 -> false; 6 -> false; _ -> true end}
                          || I <- lists:seq(1, N)]),

    {_, Seen} =
        lists:foldl(fun(S, {I, Acc})->
                            V = blockchain_utils:map_to_bitvector(S),
                            {I + 1, [{I, V} | Acc]}
                    end,
                    {1, []},
                    Seen0),
    BBA = blockchain_utils:map_to_bitvector(BBA0),

    %% maybe these should vary more?

    BlockCt = 50,

    lists:foreach(
      fun(_) ->
              {ok, Block} = test_utils:create_block(ConsensusMembers, [], #{seen_votes => Seen,
                                                                      bba_completion => BBA}),
              _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self())
      end,
      lists:seq(1, BlockCt)
    ),

    {ok, OldGroup} = blockchain_ledger_v1:consensus_members(Ledger),
    ct:pal("old ~p", [OldGroup]),

    %% generate new group of the same length
    New = blockchain_election:new_group(Ledger, crypto:hash(sha256, "foo"), N, 0),
    New1 = blockchain_election:new_group(Ledger, crypto:hash(sha256, "foo"), N, 1000),

    ct:pal("new ~p new1 ~p", [New, New1]),

    ?assertEqual(N, length(New)),
    ?assertEqual(N, length(New1)),

    ?assertNotEqual(OldGroup, New),
    ?assertNotEqual(OldGroup, New1),
    ?assertNotEqual(New, New1),

    %% confirm that they're sorted by score
    Scored =
        [begin
             {ok, I} = blockchain_ledger_v1:find_gateway_info(Addr, Ledger),
             {_, _, Score} = blockchain_ledger_gateway_v2:score(Addr, I, 1, Ledger),
             {Score, Addr}
         end
         || Addr <- New],

    ScoredOldGroup =
        [begin
             {ok, I} = blockchain_ledger_v1:find_gateway_info(Addr, Ledger),
             %% this is at the wrong res but it shouldn't matter?
             Loc = blockchain_ledger_gateway_v2:location(I),
             {_, _, Score} = blockchain_ledger_gateway_v2:score(Addr, I, 1, Ledger),
             {Score, Loc, Addr}
         end
         || Addr <- OldGroup],


    ct:pal("scored ~p", [Scored]),

    %% no dupes
    ?assertEqual(lists:usort(Scored), lists:sort(Scored)),

    ?assertEqual(1, length(New -- OldGroup)),

    Adjusted = blockchain_election:adjust_old_group(ScoredOldGroup, Ledger),

    ct:pal("adjusted ~p", [Adjusted]),

    {ControlScore, _, _} = lists:nth(1, Adjusted),
    {FiveScore, _, _} = lists:nth(5, Adjusted),
    {SixScore, _, _} = lists:nth(6, Adjusted),
    {SevenScore, _, _} = lists:nth(7, Adjusted),

    {ok, BBAPenalty} = blockchain_ledger_v1:config(?election_bba_penalty, Ledger),
    {ok, SeenPenalty} = blockchain_ledger_v1:config(?election_seen_penalty, Ledger),

    %% five should have taken both hits
    FiveTarget = normalize_float(ControlScore - normalize_float((BlockCt * BBAPenalty + BlockCt * SeenPenalty))),
    ?assertEqual(FiveTarget, FiveScore),

    %% six should have taken only the BBA hit
    SixTarget = normalize_float(ControlScore - (BlockCt * BBAPenalty)),
    ?assertEqual(SixTarget, SixScore),

    %% seven should not have been penalized
    ?assertEqual(ControlScore, SevenScore),
    ok.


chain_vars_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    {Priv, _} = ?config(master_key, Config),

    Ledger = blockchain:ledger(Chain),

    Vars = #{poc_version => 2},

    ct:pal("priv_key ~p", [Priv]),

    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),

    {ok, InitBlock} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, InitBlock, Chain, self()),

    {ok, Delay} = blockchain:config(?vars_commit_delay, Ledger),
    ct:pal("commit delay ~p", [Delay]),
    %% Add some blocks,
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
                {ok, Height} = blockchain:height(Chain),
                case blockchain:config(poc_version, Ledger) of % ignore "?"
                    {error, not_found} when Height < (Delay + 1) ->
                        ok;
                    {ok, 2} when Height >= (Delay + 1) ->
                        ok;
                    Res ->
                        throw({error, {chain_var_wrong_height, Res, Height}})
                end
        end,
        lists:seq(1, 15)
    ),
    ?assertEqual({ok, 17}, blockchain:height(Chain)),
    ok.

chain_vars_set_unset_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    {Priv, _} = ?config(master_key, Config),

    Ledger = blockchain:ledger(Chain),

    Vars = #{poc_version => 2},

    ct:pal("priv_key ~p", [Priv]),

    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),

    {ok, InitBlock} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, InitBlock, Chain, self()),

    {ok, Delay} = blockchain:config(?vars_commit_delay, Ledger),
    ct:pal("commit delay ~p", [Delay]),
    %% Add some blocks,
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
                {ok, Height} = blockchain:height(Chain),
                case blockchain:config(poc_version, Ledger) of % ignore "?"
                    {error, not_found} when Height < (Delay + 1) ->
                        ok;
                    {ok, 2} when Height >= (Delay + 1) ->
                        ok;
                    Res ->
                        throw({error, {chain_var_wrong_height, Res, Height}})
                end
        end,
        lists:seq(1, 15)
    ),
    ?assertEqual({ok, 17}, blockchain:height(Chain)),
    {ok, Height} = blockchain:height(Chain),
    ct:pal("Height ~p", [Height]),

    UnsetVarTxn = blockchain_txn_vars_v1:new(#{}, 4, #{unsets => [poc_version]}),
    UnsetProof = blockchain_txn_vars_v1:create_proof(Priv, UnsetVarTxn),
    UnsetVarTxn1 = blockchain_txn_vars_v1:proof(UnsetVarTxn, UnsetProof),

    {ok, NewBlock} = test_utils:create_block(ConsensusMembers, [UnsetVarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, NewBlock, Chain, self()),
    %% Add some blocks,
    lists:foreach(
        fun(_) ->
                {ok, Block1} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block1, Chain, self()),
                {ok, Height1} = blockchain:height(Chain),
                ct:pal("Height1 ~p", [Height1]),
                case blockchain:config(poc_version, Ledger) of % ignore "?"
                    {ok, 2} when Height1 < (Height + Delay + 1) ->
                        ok;
                    {error, not_found} when Height1 >= (Height + Delay) ->
                        ok;
                    Res ->
                        throw({error, {chain_var_wrong_height, Res, Height1, Height + Delay + 1}})
                end
        end,
        lists:seq(1, 15)
    ),
    ?assertEqual({ok, 33}, blockchain:height(Chain)),

    ok.

token_burn_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Ledger = blockchain:ledger(Chain),

    % Step 1: Simple payment txn with no fees
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    Tx0 = blockchain_txn_payment_v1:new(Payer, Recipient, 2500, 0, 1),
    SignedTx0 = blockchain_txn_payment_v1:sign(Tx0, SigFun),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [SignedTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block2)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block2}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block2}, blockchain:get_block(2, Chain)),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500, blockchain_ledger_entry_v1:balance(NewEntry0)),
    {ok, NewEntry1} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500, blockchain_ledger_entry_v1:balance(NewEntry1)),

    % Step 2: Token burn txn (without a rate) should fail and stay at same block
    BurnTx0 = blockchain_txn_token_burn_v1:new(Payer, 10, 2),
    SignedBurnTx0 = blockchain_txn_token_burn_v1:sign(BurnTx0, SigFun),
    {error, {invalid_txns, [SignedBurnTx0]}} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),

    ?assertEqual({ok, blockchain_block:hash_block(Block2)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block2}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block2}, blockchain:get_block(2, Chain)),
    ?assertEqual({error, not_found}, blockchain_ledger_v1:find_dc_entry(Payer, Ledger)),
    ?assertEqual({error, not_found}, blockchain_ledger_v1:token_burn_exchange_rate(Ledger)),

    % Step 3: Add exchange rate to ledger
    Rate = 1000000,
    {Priv, _} = ?config(master_key, Config),
    Vars = #{token_burn_exchange_rate => Rate},
    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),
    {ok, Block3} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block3, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block3)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block3}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 3}, blockchain:height(Chain)),
    ?assertEqual({ok, Block3}, blockchain:get_block(3, Chain)),
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self())
        end,
        lists:seq(1, 20)
    ),
    ?assertEqual({ok, Rate}, blockchain_ledger_v1:config(?token_burn_exchange_rate, Ledger)),

    % Step 4: Retry token burn txn should pass now
    {ok, Block24} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block24, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block24)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block24}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 24}, blockchain:height(Chain)),
    ?assertEqual({ok, Block24}, blockchain:get_block(24, Chain)),
    {ok, NewEntry2} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500 - 10, blockchain_ledger_entry_v1:balance(NewEntry2)),
    {ok, DCEntry0} = blockchain_ledger_v1:find_dc_entry(Payer, Ledger),
    ?assertEqual(10*Rate, blockchain_ledger_data_credits_entry_v1:balance(DCEntry0)),

    % Step 5: Try payment txn with fee this time
    Fee = 10,
    Tx1 = blockchain_txn_payment_v1:new(Payer, Recipient, 500, Fee, 3),
    SignedTx1 = blockchain_txn_payment_v1:sign(Tx1, SigFun),
    {ok, Block25} = test_utils:create_block(ConsensusMembers, [SignedTx1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block25, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block25)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block25}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 25}, blockchain:height(Chain)),
    ?assertEqual({ok, Block25}, blockchain:get_block(25, Chain)),
    {ok, NewEntry3} = blockchain_ledger_v1:find_entry(Recipient, Ledger),
    ?assertEqual(Balance + 2500 + 500, blockchain_ledger_entry_v1:balance(NewEntry3)),
    {ok, NewEntry4} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 2500 - 10 - 500, blockchain_ledger_entry_v1:balance(NewEntry4)),
    {ok, DCEntry1} = blockchain_ledger_v1:find_dc_entry(Payer, Ledger),
    ?assertEqual((10*Rate)-Fee, blockchain_ledger_data_credits_entry_v1:balance(DCEntry1)),

    ok.

payer_test(Config) ->
    BaseDir = ?config(base_dir, Config),

    ConsensusMembers = ?config(consensus_members, Config),
    Balance = ?config(balance, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),

    [_, {Payer, {_, PayerPrivKey, _}}, {Owner, {_, OwnerPrivKey, _}}|_] = ConsensusMembers,
    PayerSigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    OwnerSigFun = libp2p_crypto:mk_sig_fun(OwnerPrivKey),
    Ledger = blockchain:ledger(Chain),


    % Step 1: Add exchange rate to ledger
    Rate = 1000000,
    {Priv, _} = ?config(master_key, Config),
    Vars = #{token_burn_exchange_rate => Rate},

    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block2)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block2}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block2}, blockchain:get_block(2, Chain)),
    Blocks = lists:map(
               fun(_) ->
                       {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                       _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self()),
                       Block
               end,
               lists:seq(1, 20)),
    ?assertEqual({ok, Rate}, blockchain_ledger_v1:config(?token_burn_exchange_rate, Ledger)),

    % Step 2: Token burn txn should pass now
    BurnTx0 = blockchain_txn_token_burn_v1:new(Payer, 10, 1),
    SignedBurnTx0 = blockchain_txn_token_burn_v1:sign(BurnTx0, PayerSigFun),
    {ok, Block23} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block23, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block23)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block23}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 23}, blockchain:height(Chain)),
    ?assertEqual({ok, Block23}, blockchain:get_block(23, Chain)),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Payer, Ledger),
    ?assertEqual(Balance - 10, blockchain_ledger_entry_v1:balance(NewEntry0)),
    {ok, DCEntry0} = blockchain_ledger_v1:find_dc_entry(Payer, Ledger),
    ?assertEqual(10*Rate, blockchain_ledger_data_credits_entry_v1:balance(DCEntry0)),

    % Step 3: Add OUI, gateway, assert_location and let payer pay for it
    Addresses0 = [libp2p_swarm:pubkey_bin(Swarm)],
    {Filter, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn0 = blockchain_txn_oui_v1:new(Owner, Addresses0, Filter, 8, Payer, 1, 10),
    SignedOUITxn0 = blockchain_txn_oui_v1:sign(OUITxn0, OwnerSigFun),
    SignedOUITxn1 = blockchain_txn_oui_v1:sign_payer(SignedOUITxn0, PayerSigFun),


    #{public := GatewayPubKey, secret := GatewayPrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Gateway = libp2p_crypto:pubkey_to_bin(GatewayPubKey),
    GatewaySigFun = libp2p_crypto:mk_sig_fun(GatewayPrivKey),

    AddGatewayTx = blockchain_txn_add_gateway_v1:new(Owner, Gateway, Payer, 1, 10),
    SignedAddGatewayTx0 = blockchain_txn_add_gateway_v1:sign(AddGatewayTx, OwnerSigFun),
    SignedAddGatewayTx1 = blockchain_txn_add_gateway_v1:sign_request(SignedAddGatewayTx0, GatewaySigFun),
    SignedAddGatewayTx2 = blockchain_txn_add_gateway_v1:sign_payer(SignedAddGatewayTx1, PayerSigFun),

    AssertLocationRequestTx = blockchain_txn_assert_location_v1:new(Gateway, Owner, Payer, ?TEST_LOCATION, 1, 1, 10),
    SignedAssertLocationTx0 = blockchain_txn_assert_location_v1:sign_request(AssertLocationRequestTx, GatewaySigFun),
    SignedAssertLocationTx1 = blockchain_txn_assert_location_v1:sign(SignedAssertLocationTx0, OwnerSigFun),
    SignedAssertLocationTx2 = blockchain_txn_assert_location_v1:sign_payer(SignedAssertLocationTx1, PayerSigFun),

    {ok, Block24} = test_utils:create_block(ConsensusMembers, [SignedOUITxn1, SignedAddGatewayTx2, SignedAssertLocationTx2]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block24, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block24)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block24}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 24}, blockchain:height(Chain)),
    ?assertEqual({ok, Block24}, blockchain:get_block(24, Chain)),
    {ok, DCEntry1} = blockchain_ledger_v1:find_dc_entry(Payer, Ledger),
    ?assertEqual(10*Rate-11*3, blockchain_ledger_data_credits_entry_v1:balance(DCEntry1)),


    Routing = blockchain_ledger_routing_v1:new(1, Owner, Addresses0, Filter, <<0,0,0,127,255,254>>, 0),
    ?assertEqual({ok, Routing}, blockchain_ledger_v1:find_routing(1, Ledger)),

    {ok, GwInfo} = blockchain_ledger_v1:find_gateway_info(Gateway, blockchain:ledger(Chain)),
    ?assertEqual(Owner, blockchain_ledger_gateway_v2:owner_address(GwInfo)),
    ?assertEqual(?TEST_LOCATION, blockchain_ledger_gateway_v2:location(GwInfo)),

    %% try resyncing the ledger
    {ok, NewChain} = blockchain:reset_ledger(Chain),

    ?assertEqual({ok, blockchain_block:hash_block(Block24)}, blockchain:head_hash(NewChain)),
    ?assertEqual({ok, Block24}, blockchain:head_block(NewChain)),
    ?assertEqual({ok, 24}, blockchain:height(NewChain)),
    ?assertEqual({ok, Block24}, blockchain:get_block(24, NewChain)),
    {ok, DCEntry1} = blockchain_ledger_v1:find_dc_entry(Payer, blockchain:ledger(NewChain)),
    ?assertEqual(10*Rate-11*3, blockchain_ledger_data_credits_entry_v1:balance(DCEntry1)),

    blockchain:delete_block(Block23, NewChain),

    ?assertEqual({error, {missing_block, blockchain_block:hash_block(Block23), blockchain_block:height(Block23)}}, blockchain:reset_ledger(NewChain)),

    {ok, NewerChain} = blockchain:reset_ledger(20, NewChain),

    ?assertEqual(blockchain:head_hash(NewerChain), {ok, blockchain_block:hash_block(lists:nth(18, Blocks))}),
    ?assertEqual({ok, 20}, blockchain:height(NewerChain)),
    ?assertEqual({ok, lists:nth(18, Blocks)}, blockchain:head_block(NewerChain)),
    ?assertEqual({ok, lists:nth(18, Blocks)}, blockchain:get_block(20, NewerChain)),

    blockchain:add_blocks(Blocks ++ [Block23, Block24], NewerChain),

    ?assertEqual({ok, blockchain_block:hash_block(Block24)}, blockchain:head_hash(NewerChain)),
    ?assertEqual({ok, Block24}, blockchain:head_block(NewerChain)),
    ?assertEqual({ok, 24}, blockchain:height(NewerChain)),
    ?assertEqual({ok, Block24}, blockchain:get_block(24, NewerChain)),
    {ok, DCEntry1} = blockchain_ledger_v1:find_dc_entry(Payer, blockchain:ledger(NewerChain)),
    ?assertEqual(10*Rate-11*3, blockchain_ledger_data_credits_entry_v1:balance(DCEntry1)),

    ok.

poc_sync_interval_test(Config) ->
    ConsensusMembers = ?config(consensus_members, Config),
    PubKey = ?config(pubkey, Config),
    PrivKey = ?config(privkey, Config),
    Owner = libp2p_crypto:pubkey_to_bin(PubKey),
    Chain = ?config(chain, Config),
    Swarm = ?config(swarm, Config),
    Balance = ?config(balance, Config),

    Ledger = blockchain:ledger(Chain),
    Rate = 1000000,
    {Priv, _} = ?config(master_key, Config),
    VarTxn = fake_var_txn(Priv, 3, #{token_burn_exchange_rate => Rate}),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [VarTxn]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block2)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block2}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 2}, blockchain:height(Chain)),
    ?assertEqual({ok, Block2}, blockchain:get_block(2, Chain)),

    ok = dump_empty_blocks(Chain, ConsensusMembers, Swarm, 20),

    ?assertEqual({ok, Rate}, blockchain_ledger_v1:config(?token_burn_exchange_rate, Ledger)),

    % Step 2: Token burn txn should pass now
    OwnerSigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    BurnTx0 = blockchain_txn_token_burn_v1:new(Owner, 10, 1),
    SignedBurnTx0 = blockchain_txn_token_burn_v1:sign(BurnTx0, OwnerSigFun),
    {ok, Block23} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block23, Chain, self()),

    ?assertEqual({ok, blockchain_block:hash_block(Block23)}, blockchain:head_hash(Chain)),
    ?assertEqual({ok, Block23}, blockchain:head_block(Chain)),
    ?assertEqual({ok, 23}, blockchain:height(Chain)),
    ?assertEqual({ok, Block23}, blockchain:get_block(23, Chain)),
    {ok, NewEntry0} = blockchain_ledger_v1:find_entry(Owner, Ledger),
    ?assertEqual(Balance - 10, blockchain_ledger_entry_v1:balance(NewEntry0)),
    {ok, DCEntry0} = blockchain_ledger_v1:find_dc_entry(Owner, Ledger),
    ?assertEqual(10*Rate, blockchain_ledger_data_credits_entry_v1:balance(DCEntry0)),

    %% Get gateways before adding a new gateway
    ActiveGateways0 = blockchain_ledger_v1:active_gateways(blockchain:ledger(Chain)),

    %% Add gateway with a location
    {Gateway, GatewaySigFun} = create_gateway(),
    SignedAddGatewayTx = fake_add_gateway(Owner, OwnerSigFun, Gateway, GatewaySigFun),
    SignedAssertLocTx = fake_assert_location(Owner, OwnerSigFun, Gateway, GatewaySigFun, ?TEST_LOCATION),
    Txns = [SignedAddGatewayTx, SignedAssertLocTx],

    %% Put the txns in a block
    {ok, Block24} = test_utils:create_block(ConsensusMembers, Txns),
    _ = blockchain_gossip_handler:add_block(Swarm, Block24, Chain, self()),

    %% Check chain moved ahead
    {ok, HeadHash} = blockchain:head_hash(Chain),
    ?assertEqual(blockchain_block:hash_block(Block24), HeadHash),
    ?assertEqual({ok, Block24}, blockchain:get_block(HeadHash, Chain)),
    ?assertEqual({ok, 24}, blockchain:height(Chain)),

    %% Check that gateway made in, there should be 1 new
    ActiveGateways = blockchain_ledger_v1:active_gateways(blockchain:ledger(Chain)),
    {ok, AddedGw} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    ?assertEqual(1, maps:size(ActiveGateways) - maps:size(ActiveGateways0)),

    %% Check that the add gateway is eligible for POC before chain vars kick in
    ?assertEqual(true, blockchain_poc_path:check_sync(AddedGw, Ledger)),

    %% Prep chain vars
    POCVersion = 2,
    POCChallengeSyncInterval = 10,
    VarTxn2 = fake_var_txn(Priv,
                           4,
                           #{poc_version => POCVersion,
                             poc_challenge_sync_interval => POCChallengeSyncInterval}
                          ),

    %% Forge a chain var block
    {ok, Block25} = test_utils:create_block(ConsensusMembers, [VarTxn2]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block25, Chain, self()),

    %% Wait for things to settle
    timer:sleep(500),

    %% Dump some more blocks
    ok = dump_empty_blocks(Chain, ConsensusMembers, Swarm, 20),

    %% Chain vars should have kicked in by now
    ?assertEqual({ok, POCVersion},
                 blockchain_ledger_v1:config(?poc_version, Ledger)),
    ?assertEqual({ok, POCChallengeSyncInterval},
                 blockchain_ledger_v1:config(?poc_challenge_sync_interval, Ledger)),

    %% Chain should have moved further up
    ?assertEqual({ok, 45}, blockchain:height(Chain)),

    %% Added gateway's poc eligibility should no longer be valid
    ?assertEqual(false, blockchain_poc_path:check_sync(AddedGw, Ledger)),

    %% Fake a poc_request
    {ok, BlockHash} = blockchain:head_hash(Chain),
    POCReqTxn = fake_poc_request(Gateway, GatewaySigFun, BlockHash),
    {ok, Block46} = test_utils:create_block(ConsensusMembers, [POCReqTxn]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block46, Chain, self()),

    %% Dump a couple more blocks
    ok = dump_empty_blocks(Chain, ConsensusMembers, Swarm, 2),

    %% Check last_poc_challenge for added gateway is updated
    {ok, AddedGw2} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    LastPOCChallenge = blockchain_ledger_gateway_v2:last_poc_challenge(AddedGw2),
    ?assert(LastPOCChallenge > 45),

    %% Added gateway's poc eligibility should become valid
    {ok, AddedGw3} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    ?assertEqual(true, blockchain_poc_path:check_sync(AddedGw3, Ledger)),

    %% Dump even more blocks to make it ineligible again
    ok = dump_empty_blocks(Chain, ConsensusMembers, Swarm, 20),
    {ok, AddedGw4} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    ?assertEqual(false, blockchain_poc_path:check_sync(AddedGw4, Ledger)),

    ok.

zero_payment_v1_test(Config) ->
    BaseDir = ?config(base_dir, Config),
    ConsensusMembers = ?config(consensus_members, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),

    % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Amount = 0,
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, Amount, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),

    %% TODO: update when dc stuff with better test_util add_block lands
    {[], [SignedTx]} = blockchain_txn:validate([SignedTx], Chain),

    ok.

negative_payment_v1_test(Config) ->
    BaseDir = ?config(base_dir, Config),
    ConsensusMembers = ?config(consensus_members, Config),
    BaseDir = ?config(base_dir, Config),
    Chain = ?config(chain, Config),

    % Test a payment transaction, add a block and check balances
    [_, {Payer, {_, PayerPrivKey, _}}|_] = ConsensusMembers,
    Recipient = blockchain_swarm:pubkey_bin(),
    Amount = -100,
    Tx = blockchain_txn_payment_v1:new(Payer, Recipient, Amount, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PayerPrivKey),
    SignedTx = blockchain_txn_payment_v1:sign(Tx, SigFun),

    %% TODO: update when dc stuff with better test_util add_block lands
    {[], [SignedTx]} = blockchain_txn:validate([SignedTx], Chain),

    ok.

zero_amt_htlc_create_test(Config) ->
    PubKey = ?config(pubkey, Config),
    PrivKey = ?config(privkey, Config),
    Chain = ?config(chain, Config),

    % Create a Payer
    Payer = libp2p_crypto:pubkey_to_bin(PubKey),
    % Create a Payee
    #{public := PayeePubKey, secret := _PayeePrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Payee = libp2p_crypto:pubkey_to_bin(PayeePubKey),
    % Generate a random address
    HTLCAddress = crypto:strong_rand_bytes(33),
    % Create a Hashlock
    Hashlock = crypto:hash(sha256, <<"sharkfed">>),
    Amount = 0,
    CreateTx = blockchain_txn_create_htlc_v1:new(Payer, Payee, HTLCAddress, Hashlock, 3, Amount, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    SignedCreateTx = blockchain_txn_create_htlc_v1:sign(CreateTx, SigFun),

    %% TODO: update when dc stuff with better test_util add_block lands
    {[], [SignedCreateTx]} = blockchain_txn:validate([SignedCreateTx], Chain),
    ok.

negative_amt_htlc_create_test(Config) ->
    PubKey = ?config(pubkey, Config),
    PrivKey = ?config(privkey, Config),
    Chain = ?config(chain, Config),

    % Create a Payer
    Payer = libp2p_crypto:pubkey_to_bin(PubKey),
    % Create a Payee
    #{public := PayeePubKey, secret := _PayeePrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Payee = libp2p_crypto:pubkey_to_bin(PayeePubKey),
    % Generate a random address
    HTLCAddress = crypto:strong_rand_bytes(33),
    % Create a Hashlock
    Hashlock = crypto:hash(sha256, <<"sharkfed">>),
    Amount = -100,
    CreateTx = blockchain_txn_create_htlc_v1:new(Payer, Payee, HTLCAddress, Hashlock, 3, Amount, 0, 1),
    SigFun = libp2p_crypto:mk_sig_fun(PrivKey),
    SignedCreateTx = blockchain_txn_create_htlc_v1:sign(CreateTx, SigFun),

    %% TODO: update when dc stuff with better test_util add_block lands
    {[], [SignedCreateTx]} = blockchain_txn:validate([SignedCreateTx], Chain),
    ok.

update_gateway_oui_test(Config) ->
    ConsensusMembers = proplists:get_value(consensus_members, Config),
    Chain = proplists:get_value(chain, Config),
    Swarm = proplists:get_value(swarm, Config),
    Ledger = blockchain:ledger(Chain),

    [_, {Owner, {_, OwnerPrivKey, _}}|_] = ConsensusMembers,
    OwnerSigFun = libp2p_crypto:mk_sig_fun(OwnerPrivKey),

    % Step 1: Add exchange rate to ledger
    Rate = 1000000,
    {Priv, _} = proplists:get_value(master_key, Config),
    Vars = #{token_burn_exchange_rate => Rate},
    VarTxn = blockchain_txn_vars_v1:new(Vars, 3),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    VarTxn1 = blockchain_txn_vars_v1:proof(VarTxn, Proof),
    {ok, Block2} = test_utils:create_block(ConsensusMembers, [VarTxn1]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block2, Chain, self()),
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self())
        end,
        lists:seq(1, 20)
    ),
    ok = test_utils:wait_until(fun() -> {ok, 22} == blockchain:height(Chain) end),
    ?assertEqual({ok, Rate}, blockchain_ledger_v1:config(?token_burn_exchange_rate, Ledger)),

    % Step 2: Burn some token to get some DCs
    BurnTx0 = blockchain_txn_token_burn_v1:new(Owner, 10, 1),
    SignedBurnTx0 = blockchain_txn_token_burn_v1:sign(BurnTx0, OwnerSigFun),

    {ok, Block23} = test_utils:create_block(ConsensusMembers, [SignedBurnTx0]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block23, Chain, self()),
    ok = test_utils:wait_until(fun() -> {ok, 23} == blockchain:height(Chain) end),

    % Step 3: Create a Gateway and OUI
    #{public := GatewayPubKey, secret := GatewayPrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Gateway = libp2p_crypto:pubkey_to_bin(GatewayPubKey),
    GatewaySigFun = libp2p_crypto:mk_sig_fun(GatewayPrivKey),
    AddGatewayTxn = blockchain_txn_add_gateway_v1:new(Owner, Gateway, 1, 1),
    SignedOwnerAddGatewayTxn = blockchain_txn_add_gateway_v1:sign(AddGatewayTxn, OwnerSigFun),
    SignedGatewayAddGatewayTxn = blockchain_txn_add_gateway_v1:sign_request(SignedOwnerAddGatewayTxn, GatewaySigFun),
    OUI1 = 1,
    Addresses = [libp2p_swarm:pubkey_bin(Swarm)],
    {Filter, _} = xor16:to_bin(xor16:new([], fun xxhash:hash64/1)),
    OUITxn = blockchain_txn_oui_v1:new(Owner, Addresses, Filter, 8, 1, 1),
    SignedOUITxn = blockchain_txn_oui_v1:sign(OUITxn, OwnerSigFun),
    {ok, Block24} = test_utils:create_block(ConsensusMembers, [SignedGatewayAddGatewayTxn, SignedOUITxn]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block24, Chain, self()),
    ok = test_utils:wait_until(fun() -> {ok, 24} == blockchain:height(Chain) end),

    % Step 3: Updating a Gateway's OUI

    UpdateGatewayOUITxn = blockchain_txn_update_gateway_oui_v1:new(Gateway, OUI1, 1, 1),
    SignedUpdateGatewayOUITxn = blockchain_txn_update_gateway_oui_v1:oui_owner_sign(blockchain_txn_update_gateway_oui_v1:gateway_owner_sign(UpdateGatewayOUITxn, OwnerSigFun), OwnerSigFun),
    {ok, Block25} = test_utils:create_block(ConsensusMembers, [SignedUpdateGatewayOUITxn]),
    _ = blockchain_gossip_handler:add_block(Swarm, Block25, Chain, self()),
    ok = test_utils:wait_until(fun() -> {ok, 25} == blockchain:height(Chain) end),
    {ok, GwInfo} = blockchain_ledger_v1:find_gateway_info(Gateway, Ledger),
    ?assertEqual(OUI1, blockchain_ledger_gateway_v2:oui(GwInfo)),
    ok.

%%--------------------------------------------------------------------
%% Helper functions
%%--------------------------------------------------------------------

create_gateway() ->
    #{public := GatewayPubKey, secret := GatewayPrivKey} = libp2p_crypto:generate_keys(ecc_compact),
    Gateway = libp2p_crypto:pubkey_to_bin(GatewayPubKey),
    GatewaySigFun = libp2p_crypto:mk_sig_fun(GatewayPrivKey),
    {Gateway, GatewaySigFun}.

fake_add_gateway(Owner, OwnerSigFun, Gateway, GatewaySigFun) ->
    AddGatewayTx = blockchain_txn_add_gateway_v1:new(Owner, Gateway, 1, 1),
    SignedOwnerAddGatewayTx = blockchain_txn_add_gateway_v1:sign(AddGatewayTx, OwnerSigFun),
    blockchain_txn_add_gateway_v1:sign_request(SignedOwnerAddGatewayTx, GatewaySigFun).

fake_assert_location(Owner, OwnerSigFun, Gateway, GatewaySigFun, Loc) ->
    % Assert the Gateways location
    AssertLocationRequestTx = blockchain_txn_assert_location_v1:new(Gateway, Owner, Loc, 1, 1, 1),
    PartialAssertLocationTxn = blockchain_txn_assert_location_v1:sign_request(AssertLocationRequestTx, GatewaySigFun),
    blockchain_txn_assert_location_v1:sign(PartialAssertLocationTxn, OwnerSigFun).

fake_var_txn(Priv, Nonce, Vars) ->
    VarTxn = blockchain_txn_vars_v1:new(Vars, Nonce),
    Proof = blockchain_txn_vars_v1:create_proof(Priv, VarTxn),
    blockchain_txn_vars_v1:proof(VarTxn, Proof).

dump_empty_blocks(Chain, ConsensusMembers, Swarm, Count) ->
    lists:foreach(
        fun(_) ->
                {ok, Block} = test_utils:create_block(ConsensusMembers, []),
                _ = blockchain_gossip_handler:add_block(Swarm, Block, Chain, self())
        end,
        lists:seq(1, Count)
    ).

fake_poc_request(Gateway, GatewaySigFun, BlockHash) ->
    Keys0 = libp2p_crypto:generate_keys(ecc_compact),
    Secret0 = libp2p_crypto:keys_to_bin(Keys0),
    #{public := OnionCompactKey0} = Keys0,
    SecretHash0 = crypto:hash(sha256, Secret0),
    OnionKeyHash0 = crypto:hash(sha256, libp2p_crypto:pubkey_to_bin(OnionCompactKey0)),
    PoCReqTxn0 = blockchain_txn_poc_request_v1:new(Gateway, SecretHash0, OnionKeyHash0, BlockHash, 1),
    blockchain_txn_poc_request_v1:sign(PoCReqTxn0, GatewaySigFun).
